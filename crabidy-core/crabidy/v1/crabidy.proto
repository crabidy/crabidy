syntax = "proto3";
package crabidy.v1;

service CrabidyService {
  // Library
  rpc GetLibraryNode(GetLibraryNodeRequest) returns (GetLibraryNodeResponse);
  rpc GetTrack(GetTrackRequest) returns (GetTrackResponse);

  // Queue
  rpc QueueTrack(QueueTrackRequest) returns (QueueTrackResponse);
  rpc QueueLibraryNode(QueueLibraryNodeRequest) returns (QueueLibraryNodeResponse);
  rpc ReplaceWithTrack(ReplaceWithTrackRequest) returns (ReplaceWithTrackResponse);
  rpc ReplaceWithNode(ReplaceWithNodeRequest) returns (ReplaceWithNodeResponse);
  rpc AppendTrack(AppendTrackRequest) returns (AppendTrackResponse);
  rpc AppendNode(AppendNodeRequest) returns (AppendNodeResponse);
  rpc RemoveTracks(RemoveTracksRequest) returns (RemoveTracksResponse);
  rpc SetCurrentTrack(SetCurrentTrackRequest) returns (SetCurrentTrackResponse);
  rpc GetQueueUpdates(GetQueueUpdatesRequest) returns (stream GetQueueUpdatesResponse);
  rpc GetQueue(GetQueueRequest) returns (GetQueueResponse);
  rpc SaveQueue(SaveQueueRequest) returns (SaveQueueResponse);

  // Playback
  rpc TogglePlay(TogglePlayRequest) returns (TogglePlayResponse);
  rpc Stop(StopRequest) returns (StopResponse);
  rpc GetActiveTrack(GetActiveTrackRequest) returns (GetActiveTrackResponse);
  rpc GetTrackUpdates(GetTrackUpdatesRequest) returns (stream GetTrackUpdatesResponse);
}

message LibraryNodeChild {
  string uuid = 1;
  string title = 2;
}

message GetQueueRequest {}
message QueueTrackResponse {}
message QueueLibraryNodeResponse {}
message ReplaceWithTrackResponse {}
message ReplaceWithNodeResponse {}
message AppendTrackResponse {}
message AppendNodeResponse {}
message RemoveTracksResponse {}
message SetCurrentTrackResponse {}
message SaveQueueResponse {}

message TogglePlayRequest {}
message TogglePlayResponse {}
message StopRequest {}
message StopResponse {}
message GetActiveTrackRequest {}

// To signal whether it's loading data (for frontend only probably -
// could also be used for fetching from providers?)
enum LibraryNodeState {
  LIBRARY_NODE_STATE_UNSPECIFIED = 0;
  LIBRARY_NODE_STATE_PENDING = 1;
  LIBRARY_NODE_STATE_DONE = 2;
}

message Album {
  string title = 1;
  optional string release_date = 2;
}

message Artist {
  string name = 1;
}

message Track {
  // Including provider
  string uuid = 1;
  string artist = 2;
  string title = 3;
  optional uint32 duration = 4;
}

message LibraryNode {
  // Including provider
  string uuid = 1;
  string title = 2;
  repeated LibraryNodeChild children = 3;
  optional string parent = 4;
  LibraryNodeState state = 5;
  repeated Track tracks = 6;
  bool is_queable = 7;
}

message GetLibraryNodeRequest {
  string uuid = 1;
}

message GetLibraryNodeResponse {
  LibraryNode node = 1;
}

message GetTrackRequest {
  string uuid = 1;
}

message GetTrackResponse {
  Track track = 1;
}

message Queue {
  uint64 timestamp = 1;
  uint32 current = 2;
  repeated Track tracks = 3;
}

message QueuePositionChange {
  uint64 timestamp = 1;
  uint32 new_position = 2;
}

message QueueTrackRequest {
  string uuid = 1;
}

message ReplaceWithTrackRequest {
  string uuid = 1;
}

message AppendTrackRequest {
  string uuid = 1;
}

message QueueLibraryNodeRequest {
  string uuid = 1;
}

message ReplaceWithNodeRequest {
  string uuid = 1;
}

message AppendNodeRequest {
  string uuid = 1;
}

message RemoveTracksRequest {
  repeated uint32 positions = 1;
}

message SetCurrentTrackRequest {
  uint32 position = 1;
}

message GetQueueUpdatesRequest {
  uint64 timestamp = 2;
}

message GetQueueResponse {
  Queue queue = 1;
}

message GetQueueUpdatesResponse {
  oneof queue_update_result {
    Queue full = 1;
    QueuePositionChange position_change = 2;
  }
}

message SaveQueueRequest {
  string name = 1;
  // inside the configured path of crabidy
  string path = 2;
}

enum TrackPlayState {
  TRACK_PLAY_STATE_UNSPECIFIED = 0;
  TRACK_PLAY_STATE_STOPPED = 1;
  TRACK_PLAY_STATE_LOADING = 2;
  TRACK_PLAY_STATE_PLAYING = 3;
  TRACK_PLAY_STATE_PAUSED = 4;
}

message GetTrackUpdatesRequest {
  // defines how many of the update messages should be skipped
  // before they are sent back via GetTrackUpdates
  uint32 updates_skipped = 1;
  repeated string type_whitelist = 2;
  repeated string type_blacklist = 3;
}

message ActiveTrack {
  optional Track track = 1;
  TrackPlayState play_state = 2;
  uint32 completion = 3;
}

message GetActiveTrackResponse {
  ActiveTrack active_track = 1;
}

message GetTrackUpdatesResponse {
  ActiveTrack active_track = 1;
}
